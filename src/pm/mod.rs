#[cfg(test)] mod tests;

mod dense_grid;
use dense_grid::DenseGrid;
mod endpoints_search;
mod lagrange_interpolation;
mod extremal_frequencies;
use extremal_frequencies::ExtremalFrequencies;
mod extremal_frequency_search;
mod remez;
use remez::calculate_impulse_response;
use crate::Band;

use std::f64::consts::PI;
const PI2: f64 = PI * 2.0;
const NF_MAX: usize = 128; // TODO: remove this constraint

/// The type of filter to construct.
#[derive(Copy, Clone)]
#[allow(dead_code)]
pub enum FilterType {
    MultipleBand,
    Differentiator,
    HilbertTransform,
}
#[derive(Clone)]
/// The output of the Parks-McClellan algorithm.
pub struct ParksMcclellanOutput {
    /// The length of the filter.
    pub filter_length: usize,

    /// The type of the filter generated.
    pub filter_type: FilterType,

    /// The impulse response of the filter generated by the Parks-McClellan algorithm.
    pub impulse_response: Vec<f32>,

    /// A list of the lower band edges.
    pub lower_band_edges: Vec<f32>,

    /// A list of the upper band edges.
    pub upper_band_edges: Vec<f32>,

    /// A list of the desired frequency responses for each band.
    pub desired_values: Vec<f32>,

    /// A list of all of the weightings for each band.
    pub weightings: Vec<f32>,

    /// A list of all of the deviations between the desired output and
    /// the actual output for each band.
    pub deviations: Vec<f32>,

    /// A list of all of the deviations (in dB) between the desired output
    /// and the actual output for each band.
    /// This is only filled in for `MultipleBand`-type filters.
    pub deviation_dbs: Vec<f32>,

    /// A list of the frequencies with the most error from the desired frequency response
    /// of the filter.
    pub extremal_frequencies: Vec<f32>,
}


pub fn design_filter(
    filter_length: usize,
    filter_type: FilterType,
    bands: &[Band],
    grid_density: usize
) -> ParksMcclellanOutput {
    // The filter length must be [3, NF_MAX].
    assert!(filter_length >= 3);
    assert!(filter_length <= NF_MAX);

    // Number of bands must be [1, 10].
    assert!(bands.len() >= 1);
    assert!(bands.len() <= 10);

    // grid_density must be greater than 0.
    assert!(grid_density > 0);

    // An optimal Chebyshev filter can either have "reflective" symmetry or "rotational" symmetry.
    //  - Reflective: h(k) =  h(N-1-k)
    //  - Rotational: h(k) = -h(N-1-k)
    let rotational_symmetry = match filter_type {
        FilterType::MultipleBand => false,
        FilterType::Differentiator => true,
        FilterType::HilbertTransform => true,
    };

    // The length of the impulse response can either be even or odd.
    let odd_length = filter_length % 2 != 0;

    // The number of unique coefficients in the resulting filter
    // (half will be reflected around the midpoint, but we need to include the center for odd N)
    // TODO: why don't we have to for rotational symmetry?
    let mut num_coefficients = filter_length / 2;
    if odd_length && !rotational_symmetry {
        num_coefficients += 1;
    }
    let num_coefficients = num_coefficients;

    // Set up the dense grid.
    let mut grid = DenseGrid::new(bands, filter_type, grid_density, num_coefficients, rotational_symmetry, odd_length);
    grid.reformat_grid_for_remez(rotational_symmetry, odd_length);
    let grid = grid;

    // Call the remez exchange algorithm to do the approximation problem.
    let (alpha, deviation, extremal_frequencies) = remez::remez(num_coefficients, &grid);

    // Calculate the impulse response.
    let impulse_response = calculate_impulse_response(&alpha, num_coefficients, odd_length, rotational_symmetry);

    // Calculate filter output
    let mut parks_mcclellan_output = ParksMcclellanOutput {
        filter_length: filter_length,
        filter_type: filter_type,
        impulse_response: vec![],
        lower_band_edges: vec![],
        upper_band_edges: vec![],
        desired_values: vec![],
        weightings: vec![],
        deviations: vec![],
        deviation_dbs: vec![],
        extremal_frequencies: vec![],
    };
    for j in 0..num_coefficients {
        parks_mcclellan_output.impulse_response.push(impulse_response[j]);
    }
    if rotational_symmetry && odd_length {
        parks_mcclellan_output.impulse_response.push(0.0);
    }
    for k in 0..bands.len() {
        parks_mcclellan_output.lower_band_edges.push(bands[k].lower_edge);
        parks_mcclellan_output.upper_band_edges.push(bands[k].upper_edge);
        match filter_type {
            FilterType::MultipleBand => parks_mcclellan_output.desired_values.push(bands[k].desired_value),
            FilterType::Differentiator => parks_mcclellan_output.desired_values.push(bands[k].desired_value),
            FilterType::HilbertTransform => parks_mcclellan_output.desired_values.push(bands[k].desired_value),
        }
        parks_mcclellan_output.weightings.push(bands[k].weight);

        let deviation = (deviation /(bands[k].weight as f64)) as f32;
        parks_mcclellan_output.deviations.push(deviation);
        match filter_type {
            FilterType::MultipleBand => {
                let deviation_db: f32 = 20.0 * (deviation + bands[k].desired_value).log10();
                parks_mcclellan_output.deviation_dbs.push(deviation_db);
            },
            _ => {}
        }
    }
    for j in 0..(num_coefficients + 1) {
        let grid_index = extremal_frequencies.get_grid_index(j);
        let temp = grid.get_grid(grid_index as usize - 1);
        parks_mcclellan_output.extremal_frequencies.push(temp);
    }

    parks_mcclellan_output
}